(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Generated by CoffeeScript 1.9.1
(function() {
  var Bottleneck,
    slice = [].slice;

  Bottleneck = (function() {
    Bottleneck.strategy = Bottleneck.prototype.strategy = {
      LEAK: 1,
      OVERFLOW: 2,
      BLOCK: 3
    };

    Bottleneck.Cluster = Bottleneck.prototype.Cluster = require("./Cluster");

    function Bottleneck(maxNb, minTime, highWater, strategy) {
      this.maxNb = maxNb != null ? maxNb : 0;
      this.minTime = minTime != null ? minTime : 0;
      this.highWater = highWater != null ? highWater : 0;
      this.strategy = strategy != null ? strategy : Bottleneck.prototype.strategy.LEAK;
      this._nextRequest = Date.now();
      this._nbRunning = 0;
      this._queue = [];
      this._timeouts = [];
      this._unblockTime = 0;
      this.penalty = (15 * this.minTime) || 5000;
      this.interrupt = false;
      this.reservoir = null;
      this.limiter = null;
    }

    Bottleneck.prototype.chain = function(limiter) {
      this.limiter = limiter;
      return this;
    };

    Bottleneck.prototype.check = function() {
      return (this._nbRunning < this.maxNb || this.maxNb <= 0) && (this._nextRequest - Date.now()) <= 0 && ((this.reservoir == null) || this.reservoir > 0);
    };

    Bottleneck.prototype._tryToRun = function() {
      var done, index, next, wait;
      if ((this._nbRunning < this.maxNb || this.maxNb <= 0) && this._queue.length > 0 && ((this.reservoir == null) || this.reservoir > 0)) {
        this._nbRunning++;
        if (this.reservoir != null) {
          this.reservoir--;
        }
        wait = Math.max(this._nextRequest - Date.now(), 0);
        this._nextRequest = Date.now() + wait + this.minTime;
        next = this._queue.shift();
        done = false;
        index = -1 + this._timeouts.push(setTimeout((function(_this) {
          return function() {
            var completed;
            completed = function() {
              var ref;
              if (!done) {
                done = true;
                delete _this._timeouts[index];
                _this._nbRunning--;
                _this._tryToRun();
                if (!_this.interrupt) {
                  return (ref = next.cb) != null ? ref.apply({}, Array.prototype.slice.call(arguments, 0)) : void 0;
                }
              }
            };
            if (_this.limiter != null) {
              return _this.limiter.submit.apply(_this.limiter, Array.prototype.concat.call(next.task, next.args, completed));
            } else {
              return next.task.apply({}, next.args.concat(completed));
            }
          };
        })(this), wait));
        return true;
      } else {
        return false;
      }
    };

    Bottleneck.prototype.submit = function() {
      var args, cb, i, reachedHighWaterMark, task;
      task = arguments[0], args = 3 <= arguments.length ? slice.call(arguments, 1, i = arguments.length - 1) : (i = 1, []), cb = arguments[i++];
      reachedHighWaterMark = this.highWater > 0 && this._queue.length === this.highWater;
      if (this.strategy === Bottleneck.prototype.strategy.BLOCK && (reachedHighWaterMark || this._unblockTime >= Date.now())) {
        this._unblockTime = Date.now() + this.penalty;
        this._nextRequest = this._unblockTime + this.minTime;
        this._queue = [];
        return true;
      } else if (reachedHighWaterMark) {
        if (this.strategy === Bottleneck.prototype.strategy.LEAK) {
          this._queue.shift();
        } else if (this.strategy === Bottleneck.prototype.strategy.OVERFLOW) {
          return reachedHighWaterMark;
        }
      }
      this._queue.push({
        task: task,
        args: args,
        cb: cb
      });
      this._tryToRun();
      return reachedHighWaterMark;
    };

    Bottleneck.prototype.changeSettings = function(maxNb, minTime, highWater, strategy) {
      this.maxNb = maxNb != null ? maxNb : this.maxNb;
      this.minTime = minTime != null ? minTime : this.minTime;
      this.highWater = highWater != null ? highWater : this.highWater;
      this.strategy = strategy != null ? strategy : this.strategy;
      while (this._tryToRun()) {}
      return this;
    };

    Bottleneck.prototype.changePenalty = function(penalty) {
      this.penalty = penalty != null ? penalty : this.penalty;
      return this;
    };

    Bottleneck.prototype.changeReservoir = function(reservoir) {
      this.reservoir = reservoir;
      while (this._tryToRun()) {}
      return this;
    };

    Bottleneck.prototype.incrementReservoir = function(incr) {
      if (incr == null) {
        incr = 0;
      }
      this.changeReservoir(this.reservoir + incr);
      return this;
    };

    Bottleneck.prototype.stopAll = function(interrupt) {
      var a, i, len, ref;
      this.interrupt = interrupt != null ? interrupt : this.interrupt;
      ref = this._timeouts;
      for (i = 0, len = ref.length; i < len; i++) {
        a = ref[i];
        clearTimeout(a);
      }
      this._tryToRun = function() {};
      this.submit = function() {
        return false;
      };
      return this.check = function() {
        return false;
      };
    };

    return Bottleneck;

  })();

  module.exports = Bottleneck;

}).call(this);

},{"./Cluster":2}],2:[function(require,module,exports){
// Generated by CoffeeScript 1.9.1
(function() {
  var Cluster,
    hasProp = {}.hasOwnProperty;

  Cluster = (function() {
    function Cluster(maxNb, minTime, highWater, strategy) {
      var base;
      this.maxNb = maxNb;
      this.minTime = minTime;
      this.highWater = highWater;
      this.strategy = strategy;
      this.limiters = {};
      this.Bottleneck = require("./Bottleneck");
      if (typeof (base = setInterval((function(_this) {
        return function() {
          var k, ref, results, time, v;
          time = Date.now();
          ref = _this.limiters;
          results = [];
          for (k in ref) {
            v = ref[k];
            if ((v._nextRequest + (60 * 1000 * 5)) < time) {
              results.push(delete _this.limiters[k]);
            } else {
              results.push(void 0);
            }
          }
          return results;
        };
      })(this), 60 * 1000)).unref === "function") {
        base.unref();
      }
    }

    Cluster.prototype.key = function(key) {
      var ref;
      if (key == null) {
        key = "";
      }
      return (ref = this.limiters[key]) != null ? ref : (this.limiters[key] = new this.Bottleneck(this.maxNb, this.minTime, this.highWater, this.strategy));
    };

    Cluster.prototype.all = function(cb) {
      var k, ref, results, v;
      ref = this.limiters;
      results = [];
      for (k in ref) {
        if (!hasProp.call(ref, k)) continue;
        v = ref[k];
        results.push(cb(v));
      }
      return results;
    };

    Cluster.prototype.keys = function() {
      return Object.keys(this.limiters);
    };

    return Cluster;

  })();

  module.exports = Cluster;

}).call(this);

},{"./Bottleneck":1}],3:[function(require,module,exports){
(function (global){
// Generated by CoffeeScript 1.9.1
(function() {
  module.exports = require("./Bottleneck");

  if (global.window != null) {
    global.window.Bottleneck = module.exports;
  }

}).call(this);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./Bottleneck":1}]},{},[3]);
